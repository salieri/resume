# Positions
All assets, including but not limited to currencies, stock, commodities, etc. are expressed as a `Position`.

A `Position` **must** contain:
* An **asset ledger**, which tracks the credit/debit asset transactions
* A **currency ledger**, which tracks currency credit/debit asset transactions, such as dividends; the funding of asset buys; and the resulting cash from liquidation
* A **decision log**, which tracks what decisions the system has made in terms of buy/sell/trade

A `Position` **may** contain:
* A **transaction cost ledger**, which tracks brokerage commissions, fees, and so on
* A **tax ledger**, which tracks taxes due

The operations tracked in the asset ledger are linked against the other ledgers and logs.

In other words, the position operates as a virtual account:
* When assets are bought, funds are credited to the currency ledger; then the ledger's balance is used to fund the buy operation and the funds are debited to the exchange/broker.
  * Depending on where the initial funds are located, this may lead to transaction costs.
* When assets are sold, funds from the exchange/broker are credited to the currency ledger.

# Running Costs
* All service costs, subscriptions, recurring costs, et cetera which are not directly connected to a single `Position` are considered `Running Costs`
  * For example: Coinbase One subscription; AWS costs; bank account fees, etc.
* Running costs are expressed as a **currency ledger** and a **decision log**

# Game
* A `Game` is a set of `Rounds` controlled by a `Model`.
* A `Model` is a logical system that makes decisions on what types of `Moves` to make on each `Round`.
* A `Round` is a set of `Moves` made on regular intervals, e.g. daily.
* A `Move` is a decision to buy, hold, or sell `Positions` in full or in part.
  * A `Move` is an approximation of a market order (e.g. `MARKET`, `LIMIT`, `STOP_LOSS`)
  * A `Move` may complete, not complete, or complete partially
  * The value at which the `Positions` are offered to/bought from the market is determined by the `Model`
  * Because this delayed effect, a `Move` may still be incomplete during the next `Round`; the `Model` may choose to cancel the `Move` or continue it.
  * `Moves` may be chained. E.g. "sell X=>Y, then Y=>Z, then Z=>A"
    * solves the problem of path finding trades
* A `Universe` is a snapshot of all information (e.g. market data) that the `Model` has access to at a given point in time.
* A `Model` may use any account at its disposal to make `Moves`. For example, if it is more beneficial to buy on account X and sell on account Y, as long as account Y has the assets to sell, the `Model` may do so.

## Beginning
* A `Game` **must** have a known start date.
* A `Game` **must** have a known length, expressed either in time or number of `Rounds`.
* A `Game` **must** have a set of funds given in a specific currency, called the `Start Fund`.
* A `Game` **must** specify early-exit constraints.
  * A constraint for `Catastrophic Exit`, in which the `Model` is performing so poorly that it should not be continued.
  * A constraint for `Perfect Exit`, in which the `Model` is performing so well that early liquidation is ideal.
* A `Game` **may** be initialized with a set of pre-determined `Positions`
* A `Game` **may** limit the types of assets to hold (e.g. 'crypto only')

## Gameplay
* A `Game` contains `Rounds`, which may be monthly, weekly, daily, or hourly.
* At the beginning of a `Round`, the `Model` is fed fresh information, such as:
  * Current appreciation of the `Positions`
  * Up-to-date `Universe` snapshot
* The `Model` will also have access to the historical values of:
  * The appreciation of the `Positions`
  * `Universe` snapshots
* On each `Round`, the `Model` decides which `Moves` to make. The `Model` may choose to make no `Moves` during a `Round`.
* A `Model` may choose to end the `Game` early, if it achieves its `Goal`, or if it is performing catastrophically.

## End
* At the end of a `Game`, all `Positions` assets are liquidated back to the currency with which the game was started.
* The performance of a `Game` is determined by the profits generated by the `Game` minus any taxes and transaction costs.

# Think More
* `Models` may be seasonal. For example, it may be that Model A only performs well during the winter months.
  * Also, could the day of the week the `Game` is started have an effect?
  * Also, could the day of the month the `Game` is started have an effect?
* `Models` may be reactive to market conditions. For example, it may be that Model B only performs well when demand for a certain commodity is high.
* `Models` may perform well for some niche market. E.g. penny stocks, or a specific industry like realty. Do not assume that one model will generalize across everything.
* `Models` may have an expiration date; e.g. five-years of training data may yield a poorly performing model whereas one year of training data may perform better;
  * Must track model's performance over time
  * Must test different timespans for training
  * Should train on T-0 data? Or have a cutoff date, e.g. 'last 30 days ignored'?
* Switching `Models` on and off needs to be a decision point as well based on market/time analysis
* => Need years of market data to analyze this
* Time of day may affect optimal sale/buy
* Should the `Rounds` be regular intervals? What if the interval either increases or decreases over time?
* Assume that you are not a real-time trader and you can't compete with them. Is it possible to operate *slower* and still be profitable?
* Assume you are the small fish. Can you scoop up enough things the big fish don't care about to make yourself profitable?
* If you buy an asset that you already own (say, on a different Game) and sell it, what's the correct way to calculate profit/loss and taxes?
  * FIFO? LIFO? Average? INTERNET SAYS IT'S FIFO
  * To be more exact, it is FIFO per brokerage/exchange account
  * LIFO and specific stock sale **is possible** but you need to communicate that clearly to your broker/exchange ('specific share identification')
* How does LLM 'memory' work (=> Cursor, for example) and how to take advantage of that?
* Must test against market downturns (2008, 2020, etc)
* Telemetry?

## `Model` Responsibilities
  * Determine starting position
  * Determine when to `Move`
  * Determine strategy for the `Move` (buy/sell/limit/etc)
  * Determine price for the `Move`
  * Determine what to do with incomplete `Moves` from previous `Rounds`
  * Early exit

## `Activator` Responsibilities
  * Determine which models to run each day

## APIs
* Polygon.io ()
* Finsheet.io (data only, no trading) ~$70/mo
* Alpaca
* Finnhub.io
* Alpha Vantage (free?!) <======
*


Data solutions
* Dolt for Postgres? (temporal database)
* What about time-series databases?
*


## Redundancy & Resliliency
* Requirement that everything is multi-region/multi-cloud from day 0
* Requirement that everything is expressed as code from day 0 (IaC) etc.
* Run As Kube from day 0?

## Learning output
* IaC
  * https://github.com/cdk8s-team/cdk8s
* Redundancy, multi-cloud, multi-region
* Kube
* Financial APIs, concepts
* Modeling, sandboxing, simulation, AI/ML, backtesting


* Requirements for Exchange/Brokerage API
  * Trading of stocks, crypto, commodities, forex
  * Specific share identification (for tax purposes)
  * Tax documents (1099-B, etc)



Requirements
* Some kind of Slack-like "pay attention to me" system for when things go wrong
* Good logging system, e.g. AWS Logs, GCP Logs, etc.







helm install my-release oci://registry-1.docker.io/bitnamicharts/postgresql

helm install \
  --repo https://go.temporal.io/helm-charts \
  -f values/values.postgresql.yaml \
  --set elasticsearch.enabled=false \
  --set server.config.persistence.default.sql.user=postgresql_user \
  --set server.config.persistence.default.sql.password=postgresql_password \
  --set server.config.persistence.visibility.sql.user=postgresql_user \
  --set server.config.persistence.visibility.sql.password=postgresql_password \
  --set server.config.persistence.default.sql.host=postgresql_host \
  --set server.config.persistence.visibility.sql.host=postgresql_host \
  temporaltest temporal --timeout 900s










